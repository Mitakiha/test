# 计算机组成和体系结构

## 数据表示

### **原反补移码**

十进制转

二进制  ==短除法==

- 原码		用8个位表示 第一位表示符号位
- 反码        负数反码第一位不变，其余位取反
- 补码         负数补码为==反码加一==
- 移码         移码为补码==第一位取反==，其余位与补码相同

正数==原码反码补码==一样

可用补码进行减法

补码和移码比原码和反码多一个数 '-0'     

原码反码范围-127~128   补码范围-128~128

### **浮动数运算**

浮点数表示：N=尾数*基数^指数^

运算过程：  对阶>尾数计算>结果格式化

特点：

- ==尾数表示补码==，阶码用移码
- ==阶码==的位数决定数的==范围==，位数越多范围越大
- ==尾数==的位数决定数的有效==精度==，位数越多精度越高
- 对阶时，==小数向大数看齐==
- 对阶是通过较==小数的尾数右移== -----==算术右移==

3.14*10^3^+1.2*10^5^-----0.0314*10^5^+1.2*10^5^

0.0314*10^5^

| 阶符 | 阶码 | 数符 |  尾数  |
| :--: | :--: | :--: | :----: |
|  0   |  5   |  0   | 0.0314 |
|      |      |      |        |

## 计算机结构

### CPU=运算器+控制器

运算器

>算术逻辑单元ALU	 算术逻辑运算
>
>累加寄存器AC    存放临时结果
>
>数据缓冲寄存器DR		数据读取
>
>状态条件寄存器PSW		状态溢出

控制器

>程序计数器PC		记录下一条指令地址
>
>指令寄存器IR		存指令
>
>地址寄存器AR		当前访问的指令地址
>
>指令译码器ID		指令地址翻译
>
>时序部件		顺序控制信号

### 体系结构分类---Flynn 冯泽云

|     类型     | 结构            | 关键特性                 | 代表                                       |
| :----------: | --------------- | ------------------------ | ------------------------------------------ |
| 单指单数SISD | 控制1处理1主存1 |                          | 单处理器系统                               |
| 单指多数SIMD | 1多多           | 异步执行一条指令         | 并行处理机，==阵列处理机==，超级向量处理机 |
| 多指单数MISD | 多1多           | ==不实际==               | 流水线计算机？？                           |
| 多指多数MIMD | 多多多          | ==作业，任务，指令==并行 | 多处理机系统，多计算机                     |

### 指令

三地址指令  a+b=c-----+abc

二地址指令   a+=b-----+ab

一地址指令  a+1----++a

### 寻址

>立即寻址方式  		==速度快==，指令==存操作数==
>
>直接寻址方式			指令存操作数的==地址==
>
>==间接==寻址方式			指令==存一个地址==，对应操作数地址
>
>寄存器寻址方式		存放操作数
>
>寄存器==间接==寻址方式		存操作数地址

### CISC(复杂)与RISC(精简)

| 指令系统类型 |              指令              | 寻址方式 |                    实现方式                    |          其他          |
| :----------: | :----------------------------: | :------: | :--------------------------------------------: | :--------------------: |
|     CISC     | 数量多，频率差别大，==可变长== |    多    |                      微码                      |       研制周期长       |
|     RISC     |   数量少，频率接近，==定长==   |    少    | 增加寄存器，硬布线逻辑控制为主，适合==流水线== | 优化编译，支持高级语言 |



​		CISC ：<u>复杂，指令数量多，频率差别大，多寻址</u>

​		RISC:	<u>精简，指令数量少，操作寄存器，单周期，少寻址，多通用寄存器，流水线</u>

### 流水线

程序执行是==多条指令重叠进行操作==，并行

:chart_with_upwards_trend:流水线周期为执行时间最长的一段

:small_red_triangle:流水线计算公式：1条指令执行时间+（指令条数-1）*流水线周期 

超标量流水线

​		==度==2：两条流水线合成

流水线吞吐率

​		==单位时间内流水线所完成的任务数量==或输出的结果数量

​	:small_red_triangle:	TP=指令条数/流水线执行时间

最大吞吐率=1/周期

## 层次化存储结构

因经济问题所以得划分存储结构

- CPU：==寄存器最快==，容量小，成本高

- Cache高速缓存：按==内容==存取

- 内存(主存)：-随机存储器RAM

  ​					  -只读存储器ROM

- 外存(辅存)：硬盘，光盘，U盘等

> Cache
>
> >Cache是访问速度==最快层次==（若有寄存器，则寄存器最快）
> >
> >依据==局部性原理==  防止抖动
>
> 映像
>
> >直接相联映像：==冲突率高==，电路简单
> >
> >全相联映像：==冲突率低==，电路难设计
> >
> >组相联映像：折中
> >
> >地址映像：将主存与Cache存储空间划分相同的页

### 主存-编址与计算

存储单元

按字编址：存储单元是==字存储单元==，即==最小寻址单位是一个字==		bit

按字节编址：存储单元是==字节存储单元==，即==最小寻址单位是一个字节==    1Byte=8位bit

> 计算题
>
> >存储器容量,存储芯片容量，求所需芯片总数
> >
> >:small_red_triangle: 总片数=总容量/每片容量
>
> 

### 总线

一条总线==同一时刻仅允许一个设备发送，但运行多个设备接收。==

> 总线分类
>
> > 数据总线：在CPU与RAM之间来回传送需要处理或需要存储的数据。
> >
> > 地址总线：指定在RAM之中存储的数据的地址。
> >
> > 控制总线：将微处理器控制单元的信号，传送到周边设备。

### 串联与并联系统

求可靠性

==类似高中物理的电阻==

### 校验码

码距：两个码字之间最少变化的二进制位数

> 奇偶校验：==可检查1位的错误==，不可纠错
>
> 循环校验码CRC：模2除法 ==只检错== 
>
> 海明码：==可检错，可纠错==   2^r^-1>=r+k

# 操作系统

## 进程管理

### 进程状态

> 进程 ==动态==
>
> > 程序==静态==在一个数据集合上运行的过程
> >
> > ==资源分配和调度==的一个独立单位
> >
> > 由程序块，进程控制块PCB，数据块==三部分组成==
>
> 进程与程序区别
>
> > 进程是程序的一次执行过程，没有程序就没有进程

==三态模型==

> 运行，就绪，等待(阻塞)

五态模型

### 进程的同步和互斥

PV操作

> 临界资源：因==互斥==需要==共享的资源== 		如==互斥模型==“打印机”
>
> 临界区：访问==临界资源的那段代码==为临界区
>
> 信号量：一种特殊变量

P:	S-1

V:	S+1

互斥信号量S的初值为1

> (==同步模型==)单缓冲区生产者，消费者问题

### 前趋图

观察入度与出度

### 死锁问题

> ==进程管理是操作系统的核心==，设计不当将出现死锁问题
>
> > ==必要条件==互斥---保持和等待---不剥夺---环路等待
> >
> > 预防：打破四大条件
> >
> > 避免：有序资源分配法，==银行家算法==

## 存储管理

### 页式存储

>将==程序与内存==均划分为==同样大小的块==，以==页为单位==将程序调入内存
>
>> 逻辑地址=页号+页内地址
>>
>> 物理地址=页帧号+页内地址
>>
>> 优点：利用率高，==碎片小==，分配及管理==简单==
>>
>> 缺点：==增加系统开销==，可能产生==抖动==现象

### 段式存储

> 按用户==作业中的自然段==来划分逻辑空间，然后==调入内存==，段的==长度可以不一样==
>
> > 优点：多道程序==共享内存==，各段程序==修改互不影响==
> >
> > 缺点：内存利用率低，内存==碎片浪费大==

### 段页式存储

> 段式和页式的综合体，==先分段，再分页==，每页大小相同，每段大小不同。
>
> > 优点：空间浪费小，存储共享容易，存储保护容易，能==动态连接==
> >
> > 缺点：管理软件增加，复杂与开销加大，增加硬件与占用内存，==执行速度下降==

### 页面置换算法

> 最优算法OPT
>
> 随机算法RAND
>
> ==先进先出FIFO：可能产生抖动==
>
> ==最近最少使用LRU：不会抖动，LRU理论“局部性原理”==
>
> 时间局部性：刚被访问的内容，立即又被访问
>
> 空间局部性：刚被访问的内容，临近的空间很快被访问

## 作业，文件，设备管理

### 作业调度算法

> 先来先服务法
>
> 时间片轮转法     根据CPU
>
> 短作业优先法
>
> 最高优先权优先法		优先级
>
> 高响应比优先法		作业等待时间/执行时间

### 文件管理--索引文件结构

13块

### 树型目录结构

绝对路径

根目录

### 数据传输控制方式

:arrow_down:

> 程序控制(查询)方式
>
> > 分为==无条件传送==和==程序查询方式==。方法==简单==，硬件开销小，但==I/O能力低==，影响CPU利用率。
>
> 程序中断方式
>
> > 与程序控制方式相比，中断方式因为==CPU无需等待==而==提高==了传输请求的==响应速度==。
>
> DMA方式
>
> > 为==主存与外设间实现高速==，==批量数据==处理而设置。DMA比程序控制方式与中断方式都==高效==。
>
> 通道方式    成本高
>
> I/O处理机

:small_red_triangle:==越往下效率越高==



## 

# 数据库系统

## 三级模式--两层映射

![1569120051746](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569120051746.png)

> (视图级)外模式——逻辑，用户
>
> > ==外模式—概念模式映射==
>
> (表级)概念模式——模式
>
> > ==概念模式—内模式映射==
>
> (文件级)内模式——存储，物理



形成==数据的独立性==

## 数据库设计过程

![1569120643953](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569120643953.png)



> 需求分析
>
> > 数据流图+数据字典（作用为对数据流图的补充说明）+需求说明书
>
> 概念结构设计
>
> > ER模型
>
> 逻辑结构设计
>
> > 关系模式
>
> 物理设计



## ER模型

弱实体：某个实体的特殊化

![1569121026682](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569121026682.png)

>一个实体型转换为一个关系模式
>
>联系转关系模式：
>
>> 1:1联系——联系合并至==任一端==
>>
>> 1:n模式——联系合并至==n端==
>>
>> n:n模式——--联系==单独转成==关系模式



## 关系代数

> 并
>
> 交
>
> 差
>
> 笛卡尔积
>
> > ![1569121572820](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569121572820.png)
> >
> > 两表相乘
>
> 投影
>
> > ![1569121724508](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569121724508.png)
> >
> > 一个表的投影+条件
>
> 选择
>
> > ![1569121742573](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569121742573.png)
> >
> > 选择条件符合的项
>
> 联接
>
> > ![1569121800356](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569121800356.png)
> >
> > 交集+合并



## 规范理论

> 数据冗余导致下面的异常
>
> 修改异常
>
> 插入异常
>
> 删除异常



> ==部分函数依赖==
>
> >![1569122470879](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569122470879.png)
>
> ==传递函数依赖==
>
> >![1569122558133](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569122558133.png)



> 键
>
> > 候选键——==唯一标识元组==，且==无冗余==，可有多个
> >
> > 主键——==候选键中任选一个==
> >
> > 外键——其他关系的主键



### 求候选键问题:small_red_triangle:

>将函数的依赖关系用“==有向图==”表示
>
>找==入度为0==属性，做起点，==遍历==有向图所有 结点，成功即为候选键
>
>若入度0不能遍历，则将==有入有出结点并入==0属性集中，直至能遍历，成为候选键



### 主属性与非主属性

==定义：组成候选码的属性就是主属性，其他的就是非主属性==



### 范式:accept:

> 第一范式(1NF)
>
> > 只包含原子值，即==属性不可再分==
>
> 第二范式(2NF)
>
> > ==每一个非主属性完全依赖候选键==
>
> 第三范式(3NF)
>
> > 当关系R是第二范式，且R中==没有非主属性传递依赖==于候选键时
>
> BC范式(BCNF)
>
> > 每个依赖的决定因素必定包含R的某个候选码



![1569124503975](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569124503975.png)



## SQL语言

> 建表
>
> >create table<表名>(<列名><数据类型>[列级完整性约束条件])
>
> 字符型:char(N)
>
> 整型：int
>
> 浮点型:float
>
> 日期型:date YYYY-MM-DD
>
> NULL(可以取空值)，not null(不能取空值)
>
> unique(取值唯一)
>
> primary key(列名) ——设主键
>
> foreign key(列名) references 表名(列名)——联接外键



### 事务

> 原子性
>
> 一致性
>
> 隔离性
>
> 持续性



> ==并发产生的问题==
>
> > 丢失更新
> >
> > 不可重复读问题 ——验算不对
> >
> > 读“脏”数据——ROLLBACK(回滚)
>
> > > > > > > 解决方案:arrow_double_down:
>
> 封锁协议
>
> > S封锁——共享锁 
> >
> > X封锁——排它锁
> >
> > 两段锁协议
>
> 死锁



# 计算机网络与信息安全

## OSI/RM七层模型



|  层  |    名称    | 主要功能                                 | 主要设备及协议                                        |
| :--: | :--------: | ---------------------------------------- | ----------------------------------------------------- |
|  7   |   应用层   | 实现具体的==应用功能==                   | POP3，FTP，HTTP，Telnet，SMTP                         |
|  6   |   表示层   | 数据的==格式与表达==，==加密==，==压缩== | DHCP，TFTP，SNMP，DNS                                 |
|  5   |   会话层   | 建立，管理和终止会话                     |                                                       |
|  4   |   传输层   | ==端==与端的连接                         | TCP，UDP                                              |
|  3   |   网络层   | ==分组传输和路由选择==—传包              | 三层交换机，路由器，ARP，RARP，IP，ICMP，IGMP         |
|  2   | 数据链路层 | 发送以==帧==为单位的信息                 | 网桥，交换机(多端口网桥)，网卡，PPTP，L2TP，SLIP，PPP |
|  1   |   物理层   | ==二进制==传输bit                        | ==中继器==，==集线器==（Hub)(多端口中继器)            |

> > > > ==传输层协议==

> TCP——传输控制协议，面向连接，本质看是==安全可靠==的”它有三次握手“
>
> UDP——用户数据包协议，面向无连接，本质是==不可靠==的
>
> > > > ==网络层==
>
> ARP——地址解析协议，把IP地址转换为MAC
>
> RARP——反向地址解析协议，把MAC转成IP
>
> ICMP——因特网控制协议，PING命令来自该协议
>
> IGMP——网关信息协议，组播协议

## TCP/IP协议族

> > > > TCP

> POP3——收邮件协议==110==			邮件收取
>
> FTP——文件传输协议，控制端口==21==，主动端口==20==，被动端口随机
>
> HTTP——超文本传输协议==80==			网页传输
>
> HTTPS——安全的超文本传输协议==443==
>
> Telnet——远程访问==23==
>
> SMTP——简单邮件传输协议==25==			邮件发送



> > > > UDP

> DHCP——动态IP地址分配==67==
>
> TFTP——文件传输协议==69==
>
> SNMP——网路管理协议==161==
>
> DNS——域名解析协议，把域名解析成服务器IP地址==53==



| POP3，FTP，HTTP，Tnlnet，SMTP       | NFS  | DHCP，TFTP,SNMP,DNS | 应用层     | 应用层，表示层，会话层 |
| ----------------------------------- | ---- | ------------------- | ---------- | ---------------------- |
| TCP                                 |      | UDP                 | 传输层     | 传输层                 |
| IP，ICMP                            | IGMP | ARP，RARP           | 网络层     | 网络层                 |
| CSMA/CD载波监听多路检测，TokingRing |      |                     | 网络接口层 | 数据了路层，物理层     |



## IP地址，子网划分

我们现在用的是IPV4 32位

分为ABCDE类，地址由前面固定位+网络号+主机号





> A类：固定位0，前8位为网络号，后24位为主机号         0~127

==主机数量应为2^24^-2==——为什么减两个？==全为0是网络地址掩码==不能用，==全为1是广播地址==不能用



> B类：固定位10，前16位为网络号，后16位为主机号		128~191
>
> C类：110，前24网络号				192~~



### 子网划分:small_red_triangle:

> 子网掩码
>
> 将一个网络划分成多个子网(取部分主机号当子网号)
>
> 将多个网络合并成一个大的网络(取部分网络号当主机号)

![1569142338541](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569142338541.png)



## 网络规划与设计

> 需求分析
>
> > ==功能，性能，运行环境，可扩充性和可维护性要求==
>
> 网络规划原则
>
> > 实用性，开放性，先进性
>
> 网络设计与实施原则
>
> > 可靠性，安全性，高效性，可扩展性
>
> 层次化网络设计
>
> > ==核心层，汇聚层，接入层==

![1569143122327](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569143122327.png)

接入层接入PC就能上网，是现在用得最多的一种布局方式



> 局域网LAN
>
> > 无线局域网WLAN，802.11   Wi-Fi
>
> 城域网MAN
>
> > 无线城域网WMAN，802.16	WiMax
>
> 广域网WAN
>
> > 无线广域网WWAN，3G/4G
>
> 因特网



### 网络接入技术

> 有线接入
>
> > 公用交换电话网络PSTN
> >
> > 数字数据网DDN
> >
> > 综合业务数字网ISDN
> >
> > ==非对称数字用户线路ADSL==
> >
> > 同轴光纤技术HFC
>
> 无线接入
>
> IEEE	802.11 WiFi 	IEEE”美国电子电器工程协会“
>
> IEEE	802.15  蓝牙Bluetooth
>
> 红外IrDA
>
> WAPI



> 3G
>
> > WCDMA——联通
> >
> > CDMA2000——电信
> >
> > TD-SCDMA——移动





## 信息安全

### ==对称加密==技术

> 使用同一套密钥
>
> 对称加密
>
> > 特点：加密强度不高，==效率高==
> >
> > ==密钥分发困难==
>
> 常见算法:small_red_triangle:
>
> ==DES，3DES，RC-5，IDEA算法==

### ==非对称加密==技术

> 公钥+私钥
>
> 密钥必须成对使用(==公钥加密，相应的私钥解密==)
>
> 非对称加密
>
> > 特点：==加密速度慢，但强度高==
>
> 常见算法:small_red_triangle:
>
> RSA，ECC(椭圆曲线加密算法)



### 数字签名

用==自己的私钥签名==，接收者用==我的公钥进行验证==



### 消息摘要

> 由==单向散列函数==加密成固定长度的散列值———==不可逆==
>
> 你好软件设计师！——产生信息摘要——%$%^%@!$#*$@
>
> > 常见算法：MD5 ==128位==，SHA ==160位==
> >
> > 

## 网络安全:camera:

![1569145065608](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569145065608.png)

![1569145111583](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569145111583.png)

![1569145144726](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569145144726.png)



DoS(拒绝服务)与DDoS(分布式拒绝服务)

黑客常见的手法

> 控制傀儡机不停向服务器发送请求，服务器忙于处理它时，真实请求来了没法处理。



## 计算机病毒与木马:racehorse:

> 病毒
>
> > ==破坏==计算机功能或破坏数据，能自我复制，的指令或代码
>
> 木马
>
> > 后门程序，被黑客控制计算机，==窃取==计算机信息，需联网



> 系统病毒(前缀：Win32，PE，W31，如：KCOM—Win32.KCOM)
>
> ==蠕虫病毒==(如：恶鹰)
>
> 木马病毒，黑客病毒(如：QQ消息尾巴木马—Trojan.QQ3344)
>
> 脚本病毒(红色代码—Script.Redlof)
>
> ==宏病毒==(如：美丽莎—Macro.Melissa)
>
> 后门病毒(如:灰鸽子—Backdoor.Win32.Huigezi)
>
> 病毒种植程序病毒(冰河播种者—Dropper.BingHe2.2C)
>
> 破坏性程序病毒(杀手命令—Harm.Command.Killer)
>
> 玩笑病毒(如：女鬼—Jioke.Grl ghost)
>
> 捆版机病毒(如：捆绑QQ—Binder.QQPass.QQBin)





# 系统开发基础

## 软件开发模型-敏捷开发方法

### 开发模型:small_red_triangle:

> ==瀑布模型==
>
> > ==需求==一开始就很==明确==
> >
> > 软件计划——可行性
> >
> > 需求分析——明确
> >
> > 软件设计——分概要设计与详细设计
> >
> > 程序编码
> >
> > 软件测试——70%的测试错误来着需求分析
> >
> > 运行维护
> >
> > ==缺点：不适合应用于超大规模软件==
>
> V模型
>
> > 很==重视测试==
> >
> > **不足**：把测试也放在编码之后，==没有做到尽量把测试提前==
> >
> > **单元测试**——测试编码，以详细设计位依据：模块接口，==局部数据结构==，边界条件，独立的路径，错误处理
> >
> > **集成测试**——测试详细设计，以概要设计位依据：==模块间==的接口和通信
> >
> > **系统测试**——测试概要设计，以需求分析为依据：恢复测试，安全性测试==硬件==
> >
> > **验收测试**——==用户主导==：有效性测试，软件配置审查，验收测试
>
> 喷泉模型
>
> > ==面向对象开发模型==
> >
> > ==迭代==：工作可以很大程度并行，提高开发效率，节约开发成本
> >
> > 缺点：提高管理难度
>
> 原型化模型&演化模型
>
> > ==用户无法表达清楚==需设计什么产品
> >
> > ==沟通==产生原型，挖掘用户需求
>
> 螺旋模型
>
> > 在原型化模型与瀑布模型基础上==进化==
> >
> > 综合两类优点，增加了==风险分析==，适合==开发高风险项目==
> >
> > 缺点：成本提高



> ==统一过程RUP==
>
> > 初始
> >
> > > > 确定项目范围和边界
> > > >
> > > > 识别系统的关键用例
> > > >
> > > > 展示系统的候选架构
> > > >
> > > > 估计项目费用和时间
> > > >
> > > > 评估项目风险
> >
> > 细化
> >
> > > > 分析系统问题领域
> > > >
> > > > 建立软件架构基础
> > > >
> > > > 淘汰最高风险元素
> >
> > 构建
> >
> > > > 开发剩余的构件
> > > >
> > > > 构件组装与测试
> >
> > 交付
> >
> > > > 进行B测试
> > > >
> > > > 制作发布版本
> > > >
> > > > 用户文档定稿
> > > >
> > > > 确认新系统
> > > >
> > > > 培训，调整产品
>
> ==用例驱动，以架构为中心，迭代和增量==



> 敏捷方法
>
> > 自适应开发
> >
> > > > 猜测，合作与学习
> >
> > 水晶方法Cockburn
> >
> > > > 用最少纪律约束而仍能成功的方法
> >
> > 特性驱动开发
> >
> > 极限编程XP
> >
> > > > ==费用控制严格的公司中使用==，非常有效
> >
> > 开放式源码
> >
> > > > 程序开发人员在地域上发布很广
> >
> > 并列争球法
> >
> > > > 明确定义了的可重复的方法过程
> >
> > 
> >
> > > 基本原则：短平块的会议，小型版本发布，较少的文档，合作为重，客户直接参与，自动化测试，重构...



## 软件开发方法

### 结构化方法

> ==面向数据流==方法
>
> > 用户至上
> >
> > 严格区分工作阶段，每阶段有任务和结果
> >
> > 强调系统开发过程的整体性和全局性
> >
> > 系统开发过程过程化，文档资料标准化
> >
> > ==自顶向下，逐步分解(求精)==
>
> > ==缺点：对大型项目无能为力==



### ==面对对象方法==——喷泉模型

> 更好的==复用性==
>
> 关键在于建立一个全面，合理，统一的模型
>
> ==分析，设计，实现三个阶段，界限不明确==

### 面向服务的方法

> SOA



### ==面向数据结构==开发方法—Jakson

> Jakson



### 需求分析

> 做什么
>
> 需求的过程
>
> 应用的工具
>
> > 数据流图DFD,数据字典DD,判定表，判定树，
> >
> > ==判定表有：基本条件项，条件项，基本动作项，动作项==

### 软件设计

> 怎么做
>
> 模块设计原则
>
> 保证它的==独立性==
>
> ==高内聚，低耦合==
>
> 工具
>
> > IPO:输入处理输出图
> >
> > PDL:程序描述语言，描述上图
> >
> > PAD：问题分析图
> >
> > 程序流程图
> >
> > N/S盒图



内聚由高到低

| 内聚类型           | 描述                                           |
| ------------------ | ---------------------------------------------- |
| 功能内聚           | 完成一个==单一功能==，各部分协同工作，缺一不可 |
| 顺序内聚           | 处理元素相关，而且必须顺序执行                 |
| 通信内聚           | 所有处理元素集中在==一个数据结构==的区域上     |
| 过程内聚           | 处理元素相关，而且必须==按特定的次序==执行     |
| 瞬时内聚(时间内聚) | 所包含的任务必须在==同一时间间隔==内执行       |
| 逻辑内聚           | 完成==逻辑上==相关的一组任务                   |
| 偶然内聚           | 完成一组==没有关系或松散关系==的任务           |



耦合由低到高

| 耦合类型   | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 非直接耦合 | 两个模块之间==没有直接关系==，他们直接的联系完全是通过==主模块的控制和调用==来实现的 |
| 数据耦合   | 一组模块借助==参数表传递==简单数据                           |
| 标记耦合   | 一组模块通过==参数表传递记录消息==(==数据结构==)             |
| 控制耦合   | 模块之间传递的信息中包含用于==控制模块==b内部逻辑的信息      |
| 外部耦合   | 一组模块都==访问同一全局简单变量==，而且不是通过参数表传递该全局变量的信息 |
| 公共耦合   | 多个模块都==访问同一个公共数据环境==                         |
| 内容耦合   | 一个模块直接访问另一个模块的内部数据；一模块不通过正常入口转到另一个模块的内部；两个模块有一部分程序代码重叠；一个模块有多个入口 |



## 软件测试

> 动态测试
>
> > 黑盒测试法
> >
> > > > 等价类划分：确定无效与有效等价类，==设计用例只覆盖一个无效类==
> > > >
> > > > 边界值分析：处理边界情况时容易出错，==选取测试数据应该恰好等于，稍小于或稍大于边界值==
> > > >
> > > > 错误推测
> > > >
> > > > 因果图
> >
> > 白盒测试法
> >
> > > > 语句覆盖
> > > >
> > > > 判定覆盖
> > > >
> > > > 条件覆盖
> > > >
> > > > 条件判定覆盖
> > > >
> > > > 路径覆盖
> >
> > 灰盒测试法
>
> 静态测试
>
> > 桌前检查
> >
> > 代码审查
> >
> > 代码走查



### McCabe复杂度

> 环路复杂度公式 V=边-结点+2
>
> :small_red_triangle:封闭区间数+1=环路复杂度



## 软件维护

> 可维护性因素决定
>
> > 可理解性：文档
> >
> > 可测试性
> >
> > 可修改性
>
> 软件维护类型
>
> > 改正性维护：改正错误
> >
> > 适应性维护 ：==外部环境改变==
> >
> > 预防性维护：==将来==
> >
> > 完善性维护:small_red_triangle:：==扩充功能和改善性能==



### 软件成熟度模型CMMI

![1569159907967](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569159907967.png)

衡量一个企业的成熟度

> 初始级:==英雄==



### 横道图----甘特图



# 面向对象技术12‘:small_red_triangle:+30'

## 面向对象的基本概念

> 对象：==属性==(数据)+==方法==(操作)+对象ID
>
> 继承与泛化：==复用==机制
>
> 多态：不同对象收到==同样的消息==产生不同的结果
>
> 重载：一个类可以有多个==同名而参数类型不同的方法==
>
> 消息与消息通信：消息是异步通信的
>
> 封装：隐藏对象，对外公开接口
>
> 覆盖(重置)重写：子类重写父类方法
>
> 接口：只定义方法没实现



### 面向对象设计7大原则

> 单一职责原则：设计==目的单一==的类
>
> 开放-封闭原则：对扩展开放，==对修改封闭==
>
> 李氏替换原则：==子类可以替换父类==
>
> 依赖倒置原则：要依赖抽象，而不是具体实现；==针对接口编程，不要针对实现编程==
>
> 接口隔离原则：使用==多个专门的接口==比使用==单一的总接口要好==
>
> 组合重用原则：要==尽量使用组合==，而不是==继承==关系达到重用目的
>
> 迪米特原则(==最少知识法则==)：==一个对象==应当对其他对象有尽可能少的了解







## UML

通用建模语言

> 面向对象
>
> > Booch
> >
> > OOSE
> >
> > OMT
> >
> > > 上三种为UML2.0分为==结构图==和==行为图==:small_red_triangle:分清楚各种图分类
> >
> > Jackson——面对数据结构
> >
> > 结构化方法——面向数据流

### 结构图

> 类图:small_red_triangle:
>
> > > ![1569328494558](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569328494558.png)
>
> 对象图
>
> 包图
>
> 组合结构图
>
> 构件图
>
> ==部署图：软硬件之间映射==
>
> 制品图



### 行为图

> ==用例图：系统与外部参与者的交互==
>
> ==顺序图：强调按时间顺序==
>
> ==通信图(协作图)==
>
> 定时图
>
> 状态图
>
> 活动图：类似程序流程图，并行关系
>
> ==交互概览图==



## 设计模式的分类23个

### 创建型模式

> 工厂方法(==factory method==)模式
>
> > 定义一个创建对象的接口，但==由子类决定需要实例化哪一个类==。工厂方法使得子类实例化的过程推迟——==动态生产对象==
> >
> > 
>
> 抽象工厂(==abstract factory==)模式
>
> > 提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类——==生产成系列对象==
>
> 
>
> 原型(==prototype==)模式
>
> >用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象——==克隆对象==
>
> 
>
> 单例(==singleton==)模式:fried_shrimp:
>
> > 保证一个类只有一个实例，并提供一个==访问它的全局访问点==——==单实例==
>
> 
>
> 构建器(==builder==)模式
>
> > 将一个复杂类的表示与==其构造相分离==，使得相同的构建过程能够得出不同的表示——==复杂对象构造==



### 结构型模式

> 适配器(==adapter==)模式:baby_chick:
>
> > 将一个类的接口转换成用户希望得到的另一种接口——==转换接口==
>
> 
>
> 桥接(==bridge==)模式
>
> > 将抽象部分与它的实现部分分离——承接树拆分
>
> 
>
> 组合(==composite==)模式
>
> > 整体-部分——树形目录结构
>
> 
>
> 装饰(==decorator==)模式:video_game:
>
> > 动态地给一个对象添加一些额外的职责——附加职责
>
> 
>
> 外观==facade==模式
>
> > 定义一个高层接口，为子系统中的一组接口提供一个一致的外观——对外接口统一
>
> 
>
> 享元==flyweight==模式
>
> >文章共享文字对象
>
> 
>
> 代理==proxy==模式
>
> >为其他对象提供一种代理以控制这个对象的访问
>
> 



### 行为型模式

> 职责链==chain of responsibility==模式:banana:
>
> > 层层审批——传递职责
>
> 
>
> 命令==command==模式:blonde_man:
>
> > 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化——日志记录，可撤销
>
> 
>
> 解释器==interpreter==模式
>
> > 给定一种语言，定义它的文法表示，并定义一个解释器——虚拟机的机制
>
> 
>
> 迭代器==iterator==模式
>
> > 数据库数据集
>
> 
>
> 中介者==mediator==模式
>
> > 用中介对象，使对象不需要显式地相互调用，从而达到低耦合——不直接引用
>
> 
>
> 备忘录==memento==模式
>
> >不破坏为前提，保存状态，以后可恢复对象
>
> 
>
> 观察者==observer==模式:koala:
>
> >联动,一个对象状态改变时，所有依赖于它的对象得到通知更新，一对多
>
> 
>
> 状态==state==模式
>
> > 内部状态改变时改变它的行为，状态改变类
>
> 
>
> 策略==strategy==模式:eggplant:
>
> > 定义算法，封装起来，相互替换，独立用户而改变——==多方案==
>
> 
>
> 模板方法==template method==模式
>
> > 定义操作算法骨架，使子类不改变算法结构可重新定义算法
>
> 访问者==visitor==模式
>
> > 定义作用对象结构的操作，不改变类的前提作用于元素的新操作



# 数据结构与算法基础10'+15'

## 数组与矩阵

> 数组类型
>
> > 一维数组：a[n]的存储地址为  a+i*len
> >
> > 二维数组：a[m][n的存储地址为(按行存储)：a+(i*n+j)len    列a+(j*m+i)len
>
> 矩阵
>
> > 上三角矩阵
> >
> > 下三角矩阵



## 线性表

> 顺序表
>
> 链表
>
> > 单链表
> >
> > 循环链表
> >
> > 双向链表



> 链表的基本操作
>
> > 单链表删除结点
> >
> > 单链表插入结点
> >
> > 双向链表删除结点
> >
> > 双向链表插入结点
>
> 

### 顺序存储与链式存储对比

![1569332356872](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569332356872.png)

了解哪种在哪部分更优



### 队列与栈

> 队列：先进先出
>
> 栈：先进后出
>
> 循环队列:
>
> > 队空条件：head=tail
> >
> > 队满条件：(tail+1)%总=head



## 树与二叉树

> 满二叉树：所有的结点的度为2
>
> 完全二叉树：有右结点则一定有左结点，有左节点不一定有右结点
>
> 

### 二叉树重要特性:small_red_triangle:

> ![1569333075016](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569333075016.png)



二叉树遍历

前序遍历 根左右

中序遍历 左根右

后序遍历 左右根

层次遍历



### 最优二叉树(哈夫曼树)

> 树的路径长度
>
> 权
>
> 带权路径长度
>
> 树的带权路径长度(树的代价)

​	![1569333367565](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569333367565.png)



### 平衡二叉树

> 提出原因
>
> > 任意结点的左右子树深度相差不超过1
> >
> > 每结点的平衡度只能为-1，0，1
> >
> > 



## 图

### 完全图

> 有向图
>
> 无向图

### 图的存储

链接矩阵

![1569333638217](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569333638217.png)

链接表

![1569333683105](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569333683105.png)



### 图的遍历

> 深度优先
>
> 广度优先

### 

# 软件设计语言与语言处理程序基础3-5‘

## 编译与解释过程

> 词法错误：非法字符，关键字或标记符拼写错误
>
> 语法错误：语法结构出错，if，endif不匹配，缺分号
>
> 语义错误：死循环(动态语义)，零除数，其他逻辑错误



> 词法分析——正规式，有限自动机
>
> 语法分析——根据语言语法规则
>
> 语义分析——语义检查，数据类型

### 编译型

> 可能有中间代码

### 解释型

> 不需要产生中间代码



## 文法

> 有序四元组G=(V，T，S，P)
>
> V：非终结符
>
> T：终结符
>
> S：起始符
>
> P：产生式
>
> 正则闭包：A+
>
> 闭包：A*在正则闭包上加上A^0^

| 类型 | 别称           | 对应自动机         |
| ---- | -------------- | ------------------ |
| 0型  | 短语法         | 图灵机             |
| 1型  | 上下文有关文法 | 线性界限自动机     |
| 2型  | 上下文无关文法 | 非确定的下推自动机 |
| 3型  | 正规文法       | ==有限自动机==     |

### 语法推导树

![1569339838582](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569339838582.png)

### ==有限自动机==

> 从初态到终态
>
> 状态图的转换

## 数据类型与程序控制结构

> 常见数据类型
>
> 数字数据类型，布尔类型，字符类型，枚举类型，指针类型，引用类型
>
> 程序控制结构
>
> 顺序结构，选择结构，循环结构

### 表达式

> 前缀表达式(+ab)
>
> 中缀表达式(a+b)
>
> 后缀表达式==逆波兰式==(ab-)

### 各种程序语言特点:small_red_triangle:

- Fortran语言(科学计算，执行效率高)
- Pascal语言(为教学而设计，表达能力强，Delphi)
- C语言(指针操作能力强，高效)
- Lisp语言(函数式程序语言，符号处理，人工智能)
- C++(面向对象，高效)
- Java(面向对象，中间代码，跨平台)
- C#(面向对象，中间代码，.Net)
- Prolog(逻辑推理，简洁性，表达能力，数据库，专家系统)
- Python(解释型，面向对象，胶水(脚本)语言)



# 多媒体基础知识

## 音频相关概念

> 人耳：20Hz-20kHz
>
> 乐器：20Hz-20kHz
>
> 说话：300-3400Hz
>
> > 采样
> >
> > > 采样频率应为声音最高频率2倍——保证声音不失真
> >
> > A/D转换
> >
> > > 采样->量化->编码
> >
> > 常见音频格式
> >
> > > WAVE：微软
> > >
> > > MP3 ：MP oalur3
> > >
> > > MIDI：乐器标准
>
> 每秒容量=采样频率Hz*量化/采样位数*声道数÷8

## 图像

:small_red_triangle:

![1569376012297](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569376012297.png)



## 媒体种类

> 感觉媒体：作用于人的感觉器官，产生直接感觉的媒体—声音，图形，图像，动画等
>
> 表示媒体：人为研究加工，处理，传输感觉媒体，==各种编码方式==——文本编码，图像编码，声音编码
>
> :small_red_triangle: ==显示媒体(表现媒体)==：物理设备，==输入输出设备==
>
> 存储媒体：存储数据的物理设备——磁盘，光盘，内存等
>
> 传输媒体：传输数据的物理载体——电缆，光缆，交换设备等

## 常见多媒体标准

> JPEG-2000
>
> > ==有损&无损==，压缩比更高，==小波变换==，==医学图像应用==
>
> MPEG-1
>
> > ==离散余弦==，==VCD，MP3==
>
> MPEG-2
>
> > ==离散余弦==，Huffman，==DVD，有线/卫星电视==，AAC
>
> MPEG-4
>
> > 网络应用/可视电话，无线通信，==增强交互性==，数据权限管理，多媒体传输集成框架
>
> MPEG-7
>
> > ==多媒体内容描述接口==，具备描述功能，不是编码标准
>
> MPEG-21
>
> > 融合不同协议，制定新标准，标准集成
>
> JPEG
>
> > 有损，RGB转YUV(亮度)，离散余弦



# 知识产权与标准化2‘

## 保护范围，对象

![1569377191943](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569377191943.png)



## 保护期限

![1569377302427](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569377302427.png)



## 知识产权人确定

![1569377461298](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569377461298.png)

![1569377496234](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569377496234.png)

## 侵权判定

![1569377558315](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569377558315.png)



# 数据流图DFD

## 数据流图基本概念:small_red_triangle:

![1569378005219](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569378005219.png)



## 数据字典

对数据流的补充说明

少考



## 数据流图平衡原则

父图与子图之间的平衡

子图内平衡

错误如：

![1569378359329](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569378359329.png)

## 答题技巧

> 补充实体
>
> > 实体可能是：人物角色，组织机构，外部系统
>
> 补充存储
>
> > 存储的文字方面特征：..文件  ..表 ..库 ..清单 ..档案
>
> 补充数据流
>
> > 1数据平衡原则
> >
> > > (1)顶层图与0图对比
> > >
> > > (2)检查加工，有入有出
> >
> > 2按题干说明匹配
>
> 补充加工名
>
> > 找“动词+名词”



# 数据库设计

## 数据库设计

>

## ER模型

## 答题技巧

> 找联系
>
> 转成关系模式
>
> 主键，外键
>
> 候选码  补实体



# UML建模

### 用例图

> ![1569379263139](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569379263139.png)
>
> 包含关系：从两个或两个以上用例中==提取公共==行为  “复用”
>
> 扩展关系：混合了两种或两种以上的不同场景，将这个用例分为一个基本用例和一个或多个扩展用例
>
> 泛化关系：子用例==继承==了父用例所有的结构
>
> ![1569379583046](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569379583046.png)



### 类图与对象图

> 类图
>
> > 描述一组类，接口，协助和它们之间的关系，在OO建模最常见，给出==系统静态设计视图==
>
> 对象图
>
> > 描述一组对象及它们之间的关系，所建立的对象实例的静态快照
>
> ![1569379867468](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569379867468.png)
>
> ![1569379927177](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569379927177.png)

### 顺序图(序列图)

>顺序图是一种交互图，由一组对象或参与者以及它们之间可能==发送的消息构成==，专注于==系统的动态视图==。强调消息的==时间次序==的交互图。
>
>![1569380110026](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569380110026.png)



### 活动图

> 将进程或其他计算结构展示一步步的控制流和数据流，专注于系统的==动态视图==，对系统的==功能建模和业务流程建==模特别重要，==强调对象间的控制流程==
>
> ![1569380260464](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569380260464.png)
>
> ![1569380297560](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569380297560.png)



### 状态图

> 描述一个==状态机==，由状态，转移，事件和活动组成。给出对象的==动态视图==。对于接口，类或协助的行为建模尤为重要，==前调事件导致==的对象行为，有利于对反应式系统建模。
>
> ![1569380428259](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569380428259.png)



### 通信图

> 也是一种==交互图==，前调收发消息的对象或参与者的结构组织。顺序图和通信图表达了类似的基本概念，当强调概念不同，==顺序图强调的是时序==，==通信图强调的是对象之间的组织结构(关系)==
>
> ![1569380591880](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569380591880.png)



### 构件图

> 描述一个==封装的类和它的接口，端口==以及由内嵌的构件和连接构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的。==构件图是类图的变体。==
>
> 面向架构
>
> ![1569381201632](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569381201632.png)



### 部署图

> 描述对运行时的处理结点及在其中生存的构件的配置。给出了架构的静态部署视图，通常一个结点包含一个或多个部署图
>
> ==增加了硬件==
>
> ![1569381308680](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569381308680.png)
>
> 



# 数据结构及算法应用:small_red_triangle:难点

## 分治法

> 分而治之
>
> 对问题分解成若干个规模较小的子问题
>
> 分解，解决，合并
>
> > 斐波那契数列
> >
> > ![1569381621836](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569381621836.png)
> >
> > 二分法查找
> >
> > ![1569381738109](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569381738109.png)
> >
> > 

## 回溯法

> 选优搜索法
>
> ![1569381833334](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569381833334.png)
>
> 迷宫

## 贪心法

> 做出在==当前来说最好的选择==，==局部最优==选择，但从==整体来说不一定==是最优的选择
>
> 

## 动态规划法

> 把==问题分解==，列出各种可能的局部解，经过筛选，保证形成==全局最优解==



## 总结

> 分治法
>
> > 特征：把==一个问题拆分==成==多个小规模的相同子问题==，一般可用==递归==解决
> >
> > 经典问题：==斐波那契数列==，归并排序，快速排序，==矩阵乘法==，二分搜索，大整数乘法，汉诺塔
>
> ==动态规划法(用于求最优解)==
>
> > 特征：划分子问题，并把子问题结果使用==数组存储==，利用查询子问题结果构造最终问题最优解
> >
> > 经典问题：==斐波那契数列==，矩阵乘法，==背包问题==，LCS最长公共子序列
>
> 回溯法
>
> > 特征：==试探==，系统的搜索一个问题的所有解或任一解
> >
> > 经典问题：N皇后问题，迷宫，背包问题
>
> ==贪心法(用于求满意解)==
>
> > 特征：==局部最优==，但整体不见得最优。每部有明确的，既定的策略
> >
> > 经典问题:==背包问题(如装箱)==，多机调度，找零钱问题



## 时间复杂度

![1569382720914](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569382720914.png)



![1569382789299](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569382789299.png)



# 面向对象程序设计

## JAVA程序题

> import包：引入包中的类
>
> 类修饰符：主要有四个修饰符，public ，==abstract== ，final ，private
>
> class为关键字
>
> ==extends为继承关键字，implements为接口关键字==
>
> 引用接口interfact

## 设计模式程序实现



# 知识点补充

> 参数多态：采用==参数化模板，==通过给出不同的类型参数，使得一个结构有多种类型。如 C++语言中的函数模板和类模板属于参数多态。参数多态又叫==静态多态==，它的执行速度快，异常少，调用在编译时已经确定。参数多态是应用比较广泛的一种多态，被称为最纯的多态。
>
> 包含多态：在许多语言中都存在，最常见的例子就是==子类型化==，即一个类型是另外一个类型的子类型。一般需要进行运行时的类型检查，属于==动态多态==。包含多态的基础是虚函数。虚函数是引入了派生概念后用来表现基类和派生类的成员函数之间的一种关系。
>
> 过载多态：同一个名字在不同的==上下文==中所代表的含义不同。典型的例子是运算符重载和函数重载，属于==静态多态==。
>
> 强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。程序设计语言中基本类型的大多数操作符，在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制多态。程序员也可以显示地进行强制多态的操作。如 int+double，编译系统一般会把 int 转换为 double，然后执行 double+double 运算，这个int->double 的转换，就实现了强制多态，即可是隐式的，也可显式转换。强制多态属于==静态多态==。
> 



分布式数据库

>1.==分片透明性==：用户不必关心数据是如何分片，他们对数据的操作在全局关系上进行的，即关心如何分片对用户是透明的，因此，当分片改变时应用程序可以不变。
>
>***分片透明性是最高层次的透明性，如果用户能在全局关系一级操作，则数据如何分布，如何存储等细节不必关心，其应用程序的编写与集中式数据库相同。
>
>2.复制透明性：用户不用关心数据库在网络中的各个节点的复制情况，被复制的数据的更新都由系统自动完成。
>
>***在分布式数据库系统中，可以把一个场地的数据复制到其他场地存放，应用程序可以使用复制到本地的数据在本地完成分布式操作，避免通过网络传输数据，提高了系统的运行和查询效率。但是对于复制数据的更新操作，就要涉及到对所有复制数据的更新。
>
>3.位置透明性：用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。因此，数据分片模式的改变，如把数据从一个站点转移到另一个站点将不会影响应用程序，因而应用程序不必改写。
>
>4.逻辑透明性（局部映像透明性）：它是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关心局部DBMS支持哪种数据模型、使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统时非常重要的。
>
>==ADSL宽带==接入使用的是PPPoE协议。PPPoE提供了一种理想的接入方案，即通过一个简单的共享接入设备将多个客户网段接入到宽带骨干网络。在实际的应用中，PPPoE利用以太网的工作机理，将ADSLModem的10Base-T接口与内部以太网互联，实现PPP的动态接入。
>==PPP==是一种有效的点对点通信协议，用于通过串行接口连接的两台计算机之间的通信。如果用户通过Windows中的拨号网络，使用模拟调制解调器，则使用PPP建立会话。
>==SLIP==可使远程用户通过电话线及高速调制解调器方便地接入TCP/IP网络。



>**Ping命令网络检测由近到远操作:**

1 ping 127.0.1先检查TCP/IP协议栈是否正常

2.ping本地 ip检查网卡是否正常工作

3 ping网关地址检查和网关的连接性

4 ping远程网站检查远程连接

![img](https://img2018.cnblogs.com/blog/1532279/201905/1532279-20190514161625441-239967590.png)

https://www.cnblogs.com/weekstart/p/softexam.html





## 1

编译型语言执行比解释型语言执行速度更快，解释器参与运行程序

计算机流入流出的所有网络通信均要经过防火墙。过滤掉一些攻击。可关闭不使用的端口。

防火墙功能:访问控制；提供基于状态检测技术的ip地址，端口，用户和时间的管理控制；双向nat，提供ip地址转换和IP及tcp/udp端口映射，实现ip复用和隐藏网络结构

在一个进程中出现同一信号量的P操作与V操作，则该信号量为互斥信号量，否则为同步信号量

![1569747241313](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569747241313.png)

方法没有继承的概念，类才有继承概念

抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

单例模式是创建型模式，保证一个类仅有一个实例，提供一个访问唯一实例的全局访问点。

![1569750554299](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1569750554299.png)





> 模块结构图的主要组成有：模块，数据，控制信号和转接符号
>
> 利用PV操作可以实现资源的互斥使用
>
> 程序设计语言的基本成分包括：数据，运算，控制，传输等
>
> 程序设计语言的控制成分包括顺序，选择和循环3种结构

![1570937857222](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1570937857222.png)

![1570937889897](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1570937889897.png)

![1570937905217](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1570937905217.png)

![1570937980373](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1570937980373.png)



### 工作量估算模型

cocomoii的 层次结构中，估算选择不包括

> 对象点，功能点，源代码行

![1571219279369](C:\Users\Abon\AppData\Roaming\Typora\typora-user-images\1571219279369.png)